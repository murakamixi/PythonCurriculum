## 概要

今回は、オブジェクトを格納する配列を学習します。配列で複数の辞書を管理するところまでやってみましょう。

# この章の目標

**推定完了時間:1時間**

**1. 配列オブジェクトの使い方を学ぶ**

　今、レビュー情報の値が更新されるだけで、１つのレビューしか保存できません。これを複数のオブジェクトをまとめて管理できるよう配列オブジェクトの使い方を学びましょう。

# ⑥複数レビューを管理しよう

　前回で、メニューが複数回表示できるようになりましたね。これで、何回でもレビューを書くことができるようになりました。しかし、今のままでは、１つのレビューしか保存できなく、書くたびにレビューは上書きされてしまいます。

### このステップでできること

- 配列を扱えるようになる
- 配列に要素を追加できるようになる

### 複数の情報を扱う

　複数のレビューを扱う方法として、複数の変数を用意することが考えられますが、この方法は、辞書のところでも効果的でないことを学習しましたね。
　そこで、今回登場するのが配列というオブジェクトです。

## 配列とは
　**配列**は複数の情報を順番で管理します。

### 配列オブジェクト

　配列オブジェクトは、辞書と同じように１つの変数で多くの情報を持つことができます、配列の中にたくさんの辞書を入れることができます。ただ、辞書と違う点は、**配列は順番でオブジェクトを管理する**という点です。
　配列は、たくさん並んでいる箱を想像するとわかりやすいかもしれます。オブジェクトをリストに追加するとは、その箱にオブジェクトを順番に入れていくことを言うのです。

![](/media/editor/B-10配列のインデックスについて_20201129165133763729.png)

　箱の中に入れられた**データ（オブジェクト）はその順番と紐ずけられます**。

### 要素

　配列の中のデータは**要素**と呼ばれます。要素は順番を持って、配列に入れた順番に1、2、...と自動的に番号が振られます。

## 配列を生成してみよう

　配列オブジェクトをつくっれみましょう。配列を作る方法は以下の方法です。

```python
配列名=[]
```

　これで何も入っていない、**空の配列**ができます。最初から要素の入っている配列も作ることができます。

###### <font color='red'>コードブロックに以下を追加して実行してみましょう</font>

```python
list2=[1, 'second' , 3]
print(list2)
# [1, 'second' , 3]
```

　ここでは、**最初に書いた要素の方から順番い入ります**。つまり、１が1番目、'second'が2番目のようにです。

### 配列に要素を追加する

　配列は、辞書と同様に、定義した後からデータを追加することができます。配列へのデータの追加は<font color='red'>**.append**</font>メソッドを使います。

### append()メソッドについて

　配列に対して要素を追加するときに使うのが<font color='red'>**.append**</font>メソッドです。append()メソッドは、指定された配列の一番最後に要素を追加することができあます。以下のサンプルプログラムをみてイメージを掴んでみてください。

```python
list2=[1, 'second' , 3]
print(list2)
# 出力結果
# [1, 'second' , 3]

list2.append('fourth')
print(list2)
# 出力結果
# [1, 'second' , 3, 'fourth']
```

###### <font color='red'>コードブロックに上のサンプルプログラムを追加して実行してみましょう</font>

　一番最後に'fourth'が追加されているのを確認できましたか？
　確認できたら次へ進みましょう

## 複数のレビューを配列で管理しよう

　今まで書いてきたコードを配列を使って書き直してみましょう。イメージは以下です。

- **複数のレビューの情報を持った配列「posts」を定義する**
- **1つのレビューは今まで通り、辞書「post」で生成する**
- **レビューを書いたら辞書「post」を配列「posts」に追加する**

これで、書いたレビューが次々に配列へ入れられていきます。

![](/media/editor/B-9配列へ辞書の追加_20201129224811906445.png)

#### <font color='blue'>レビュー情報を複数管理する配列postsを生成しましょう</font>

##### [演習解答](/answer/13)

### 配列postsにレビューの情報postを追加する

　配列postsを作ることができました。あとは、レビューを書くで生成したレビューの辞書postを配列postsに追加するだけです。
　ここで、レビューアプリの全体を確認してみましょう。

```python
#レビューの入力機能
def post_review():
  post = {}
  print("ジャンルを入力してください：")
  post['genre'] = input()
  print("タイトルを入力してください：")
  post['title'] = input()
  print("感想を入力してください：")
  post['review'] = input()
  line = "---------------------------"
  # レビューの描画
  print("ジャンル : {genre}\n{line}".format(genre=post['genre'], line=line))
  print("タイトル : {title}\n{line}".format(title=post['title'], line=line))
  print("感想 :\n{review}\n{line}".format(review=post['review'], line=line))

def read_reviews():
  print('レビューを読む')

def exception():
  print("入力された値は無効な値です")

# 配列オブジェクトpostsの生成
posts = []

while True:
  print("レビュー数：0")
  print("[0]レビューを書く")
  print("[1]レビューを読む")
  print("[2]アプリを終了する")

  user_input = int(input())

  if user_input == 0: # 「レビューを書く」
    post_review()
  elif user_input == 1: # 「レビューを読む」
    read_reviews()
  elif user_input == 2: # 「プログラムを終了する」
    break
  else:
    exception()
```

　<font color='red'>**post_review()**</font>関数でが新しいpostを呼ばれるたびに生成しています。
　ですので、これを作り終えたpostを新しいpostを作る前にpostsに追加していきましょう。

 このままではエラーが起きてしまいましたね。これは**post_review関数**の中では変数postsが使えないためです。次に、この問題を解決するために**スコープ**という概念を理解しましょう。

## スコープを理解しよう

　変数には、その使える**範囲**というものがあります。それを**スコープ**と言います。
　通常、関数内では関数内で定義した変数しか扱うことができません。

### スコープ

　ある変数を利用できる範囲のことです。スコープの範囲外の変数を使おうとすると、エラーが起こります。
　先ほどのエラーは、変数postsにとってpost_review関数がスコープ外であるために起きました。ではどのようにして変数のスコープが決まるのでしょうか。具体的に見てみましょう。

### 変数のスコープ例⑴

　以下のコードは、スコープの異なる範囲が存在しません。
実行すれば、2行目のprint関数によって問題なくターミナルに「東京」と表示されるでしょう。

```python
capital = "東京"  # 首都は「東京」
print(capital)
```

しかし、次のコードは、スコープの異なる範囲にある変数を利用しようとしているため、エラーが起こります。

```python
 capital = "東京"  # 首都は「東京」

def america():
  print(capital)

america()  
```

americaという関数を作って、その中で1行目の変数capitalをprintで出力しようとしています。
しかし、 **関数内では関数内で定義した変数しか使えません。**

### 変数のスコープ例⑵

　以下の例では、同名ですがスコープの範囲が違う場所でそれぞれ定義した変数の挙動を確かめられます。

```python
capital = "東京"  # 首都は「東京」

def america():
  capital = "ワシントン"  # americaの首都「ワシントン」を再代入
  print(capital)

america()        # => ワシントン
```

4行目メソッドamerica内で変数capitalを生成しています。値は"ワシントン"という文字列です。
先に1行目でcapitalという同じ変数名で、値を"東京"という文字列として定義していますが、このファイルを実行すると、最終的には5行目のprint()で"ワシントン"と表示されます。

メソッドamerica内では、そのメソッド内で定義した4行目の変数capitalが使われます。

### スコープが異なる変数を利用できるようにする

　ここまでで、 **「メソッド内では関数内で定義した変数しか使えない」 **ということを学びました。
レビューアプリの「レビューを書く」関数post_review内で配列postsを使うにはどうすれば良いでしょうか？
　**配列postsは、 post_review関数の外で定義した変数なのでpost_review関数内では使えません。**
　関数外で定義した変数をメソッドないで使えるようにするには。**引数**というものを使います。

## 引数を使おう

　関数とは、何か値を渡して特定のルールにしたがって変更を加えたあとに何か値を返すというものだということができます。
　引数というのは、関数に値を渡す際に用いるもののことを言います。また、関数の戻り値を示す際に**return**を用います。では、引数についてみていきましょう。

### 引数

　先ほど、引数は関数に値を渡してやるものだと言いましたが、これによって、関数のスコープ外にある変数も関数の中で使うことができます。
　関数の定義のときに<font color='red'>**()**</font>の中に記述しておき、処理に利用する**仮引数**と、関数を呼ぶ際に<font color='red'>**()**</font>のなかに渡す値を記述する**実引数*があります。
　また、引数は複数用意でき、左から第一引数、第二引数と言います。

### 引数を使う上でのポイント

　引数は以下の2点のポイントがあります。

1. **関数を定義している部分と関数を呼び出す部分両方に書く**
2. **仮引数と実引数は必ずしも一致している必要はない**

　それでは、１つづつ見ていきましょう。

1. **関数を定義している部分と関数を呼び出す部分両方に書く**
　関数を定義している部分に書く**仮引数**は以下のようにかけます。

```python
def greeting(仮引数):
  処理
```

対して、**実引数**とは、関数を呼び出す際に指定する引数のことです。

```python
関数名（実引数）
```

　引数を渡して関数を実行する例を見てみましょう。

```python
def greeting(name):
  """
  nameはString型を仮定
  入力されていたnameを「'やまがたAI部', name, 'です'」のnameに代入した結果を返す
  """
  print('やまがたAI部', name, 'です')

greeting('太郎')
```

　greetingは引数として渡したものをprint()関数に入れて出力する関数です。
　はじめ、関数の定義は飛ばされ、greeting('太郎')で関数が呼び出されると<font color='red'>**実引数'太郎'**</font>がgreeting関数に渡されgreeting関数内の<font color='red'>**仮引数name**</font>に渡されgreeting関数の処理が実行されます。

2. **仮引数と実引数は必ずしも一致している必要はない**
　仮引数と実引数の名前が必ずしも同じである必要はありません。これは、先ほどの説明とかぶるのですが、関数が呼ばれた際に**実引数**を指定した場合、**その実引数が関数の仮引数に<font color='red'>代入</font>される**ことで関数で処理が行われるためです。

### 仮引数の名前について

　仮引数の名前は基本的に変数名や関数名と同様に**なんでも構いません**。ですが、みてわかるようにわかりやすく具体的名前を出来るだけつけるようにしましょう。

### 配列postsを引数として渡す

　かなり必要な知識を揃えるために遠回りしてしまいましたが、レビューアプリのつか機能を作り始めましょう。
　今回やりたいことを再度確認しますが、**配列postsに個別のレビューの辞書postを追加する**ということでしたね。早速引数を使って関数<font color='red'>**post_review**</font>内で扱えるようにしましょう。

```python
#レビューの入力機能
def post_review():#ここで引数を受け取れるようにする
  post = {}
  print("ジャンルを入力してください：")
  post['genre'] = input()
  print("タイトルを入力してください：")
  post['title'] = input()
  print("感想を入力してください：")
  post['review'] = input()
  line = "---------------------------"
  # レビューの描画
  print("ジャンル : {genre}\n{line}".format(genre=post['genre'], line=line))
  print("タイトル : {title}\n{line}".format(title=post['title'], line=line))
  print("感想 :\n{review}\n{line}".format(review=post['review'], line=line))

def read_reviews():
  print('レビューを読む')

def exception():
  print("入力された値は無効な値です")

# 配列オブジェクトpostsの生成
posts = []

while True:
  print("レビュー数：0")
  print("[0]レビューを書く")
  print("[1]レビューを読む")
  print("[2]アプリを終了する")

  user_input = int(input())

  if user_input == 0: # 「レビューを書く」
    post_review()
  elif user_input == 1: # 「レビューを読む」
    read_reviews()
  elif user_input == 2: # 「プログラムを終了する」
    break
  else:
    exception()

#以下省略
```

　関数の呼び出し元は配列postsを渡すようにします。関数<font color='red'>**post_review**</font>では<font color='red'>**a_posts**</font>という名前の仮引数で配列postsを受け取るようにしましょう。

#### <font color='blue'>post_reviewメソッドの最後で配列postsにレビューの辞書postを追加するようにしましょう</font>

##### [演習解答](/answer/14)

## レビューの数を表示しよう
　配列に要素を追加しても今は中身を出力していないので意図した通りに追加されているかわかりません。
　そこでメニュー画面に「書いたレビューの数」を表示しましょう。今まで レビュー数：0 と固定で表示していましたが、ここの値をレビュー数によって変化するように書き換えましょう。

　**レビュー数 = 配列postsの要素数**です。この要素数を0の代わりに表示するだけ完了です。

#### <font color='blue'>書いたレビューの数をメニュー画面で「レビュー数：1」のように表示させましょう</font>

配列の要素数をカウントするにはどのようにしたら良いでしょうか？考えてみましょう。

##### [演習解答](/answer/15)

## ⑥完成コード

```python
def post_review(a_posts):
  post = {}
  print("ジャンルを入力してください：")
  post['genre'] = input()
  print("タイトルを入力してください：")
  post['title'] = input()
  print("感想を入力してください：")
  post['review'] = input()
  line = "---------------------------"

  # レビューの描画
  print("ジャンル : {genre}\n{line}".format(genre=post['genre'], line=line))
  print("タイトル : {title}\n{line}".format(title=post['title'], line=line))
  print("感想 :\n{review}\n{line}".format(review=post['review'], line=line))

  return a_posts.append(post)

# def read_reviews():
# #   #asdsdad

def exception():
  print("入力された値は無効な値です")

# 配列オブジェクトpostsの生成
posts = []

while True:
  # メニューの表示
  print("レビュー数：{review_num}".format(review_num=len(posts)))
  print("[0]レビューを書く")
  print("[1]レビューを読む")
  print("[2]アプリを終了する")

  user_input = int(input())

  if user_input == 0: # 「レビューを書く」
    posts = post_review(posts)
  elif user_input == 1: # 「レビューを読む」
    # レビューを読む
    read_review()
  elif user_input == 2: # 「プログラムを終了する」
    break
  else:
    exception()
```

### 処理の流れ

```python
def post_review(a_posts):
  post = {}
  print("ジャンルを入力してください：")
  post['genre'] = input()
  print("タイトルを入力してください：")
  post['title'] = input()
  print("感想を入力してください：")
  post['review'] = input()
  line = "---------------------------"

  # レビューの描画
  print("ジャンル : {genre}\n{line}".format(genre=post['genre'], line=line))
  print("タイトル : {title}\n{line}".format(title=post['title'], line=line))
  print("感想 :\n{review}\n{line}".format(review=post['review'], line=line))

  return a_posts.append(post)

# def read_reviews():
# #   #asdsdad

def exception():
  print("入力された値は無効な値です")

# 配列オブジェクトpostsの生成
posts = []
```

　レビューの内容を保存するための配列postsを定義します。
ここでポイントとなるのは定義する場所です。各メソッドの中でも、while文の中でも、while文の後ろでもありません。

　各関数の中で定義すると、使えるのがその関数の中のみになってしまいます。今回は様々な関数やその外側で使用したいので各関数の中では定義しません。

　while文の中で定義すると繰り返すたびに配列が初期化(最初の何も入っていない状態)されてしまうため、while文の中でも定義できません。

```python
while True:
 posts=[]
```

　while文の後ろだと、そもそもすべての処理が終わっているので定義しても意味がないですね。

以上のことから、定義するのは **各関数内ではなく、かつwhile文のブロックより前** ということになります。

```python
# 配列オブジェクトpostsの生成
posts = []

while True:
```

基本的な処理は変わりません。
<font color='red'>**「メニューの表示」 → 「ターミナルからの入力」 → 「入力に応じた処理」**</font>
という流れをwhile文の中で繰り返しています。

ただし、メニューで「【0】レビューを書く」を選択したときだけ処理が変わります。

```python
if user_input == 0: # 「レビューを書く」
    post_review(posts)
```

メニューで「【0】レビューを書く」を選択すると条件分岐によって48行目の<font color='red'>**post_review**</font>関数の呼び出しが行われます。このとき **引数で配列の変数posts** を<font color='red'>**post_review**</font>関数に渡します。

```python
posts = post_review(posts)
```

　引数として渡された配列postsは、post_review関数の変数に代入されます。

再び、4行目に処理が戻ってきます。定義したpost_review関数が呼ばれたためです。

```python
def post_review(a_posts):  # 渡されたpostsの中の配列オブジェクトが変数a_postsに代入される
  # 変数a_postsとして、引数の配列オブジェクトをメソッド内で使える
```

　post_reviewメソッドは引数を受け取ります。先ほど、48行目でこのpost_reviewメソッドが呼ばれたときに引数として変数postsが渡されました。この変数postsの中にはレビューを管理するための配列オブジェクトが入っています。

引数として渡された変数postsの中に入っていた、レビューを管理するための配列オブジェクトはpost_reviewメソッドの変数a_postsに代入され、メソッド内で使用できるようになります。

```python
posts = post_review(posts)
```

```python
def post_review(a_posts):  # 渡されたpostsの中の配列オブジェクトが変数a_postsに代入される
  # 変数a_postsとして、引数の配列オブジェクトをメソッド内で使える
```

4行目から16行目では今までと同様にレビューの情報を持つ辞書を生成し、ターミナルからレビューを入力させる処理を行います。また、入力が終わったレビュー情報をターミナルに表示させます。

```python
a_posts.append(post)
```

 19行目では、生成したレビューの辞書postを引数で受け取った配列a_postsに追加します。これで配列a_postsの最後にいま入力したレビューの辞書が入りました。

```python
return a_posts.append(post)
```

変数a_postsには入力したレビューの辞書が新しく追加された配列が入っています。これを関数の呼び出し元に返してあげます。関数の最後で、関数の呼び出し元に値を返すときにはreturnを使います。
　今回は新しく書いたレビューを追加した配列であるa_postsをreturnで返すようにします。このreturnで返す値を返り値といいました。

　関数内の処理がすべて終わると、プログラムでは関数を呼び出した部分に処理が戻ります。post_review関数を呼び出したのは48行目でした。

```python
posts = post_review(posts)
```

post_review関数は返り値を返すので、変数postsにはその返り値が代入されます。

```python
posts = post_reviewの返り値
```

post_reviewメソッドの返り値は、新しく書いたレビューを追加した配列でした。この配列は元は変数postsに代入されていたものなので、結果として**postsには新しく書いたレビューが1つ追加された配列**が代入されることになります。

具体的な例として、すでに「るろうに剣心」と「君に届け」のレビューを書いたあとの状態で、新しく「アバター」のレビューを書く処理の流れを追ってみます。

最初の段階では配列の変数postsには「るろうに剣心」と「君に届け」のレビューの辞書が入っています。

- post_reviewメソッドの呼び出し

```python
posts = post_review(posts)
```

```python
def post_review(a_posts):
  # a_postsは「るろうに剣心」と「君に届け」の入っている配列
  # (48行目で引数として渡された変数postsに代入されていた配列)

  # 新たに「アバター」のレビューを投稿

  # 「アバター」のレビューを配列に追加
  a_posts.append(post)

  # メソッドの呼び出し元に新しく書いたレビューを追加した配列を返す
  return a_posts
```

- post_reviewメソッドの返り値を代入

```python
posts = post_review(posts)
# 「アバター」のレビューが新しく追加された配列を変数postsに代入
# postsには「るろうに剣心」と「君に届け」と「アバター」のレビュー情報が入った
```

こうして、結果として配列の変数postsに新しくレビューの辞書を追加することができました。

このようなソースコードが書けたら⑦へ進みましょう。

### まとめ

配列で複数のデータを保存する方法を学習できました。
大方これで、レビューアプリが完成しました。次は最後にレビューを読む機能をつけてみましょう。